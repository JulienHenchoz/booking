"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var React = require("react");
var react_1 = require("react");
var blueprint_1 = require("./blueprint");
var getDisplayName_1 = require("./utils/getDisplayName");
var getUniqueKey_1 = require("./utils/getUniqueKey");
var isReferentiallyTransparentFunctionComponent_1 = require("./utils/isReferentiallyTransparentFunctionComponent");
var hasWillReceivePropsCallback = function (e) { return e.kind === "componentWillReceivePropsCallback"; };
var AssemblyBase = (function (_super) {
    __extends(AssemblyBase, _super);
    function AssemblyBase(blueprint, target, isReferentiallyTransparent, props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.pendingDataUpdate = false;
        _this.newestState = {};
        _this.unmounted = false;
        _this.newestProps = props;
        _this.newestContext = context;
        _this.isReferentiallyTransparent = isReferentiallyTransparent;
        _this.target = target;
        _this.callbackList = blueprint.instanceCallbacks();
        _this.hasWillReceivePropsCallback = _this.callbackList.some(hasWillReceivePropsCallback);
        _this.computed = _this.runInstanceCallbacks({ props: props, context: context, component: _this.target });
        _this.state = _this.newestState;
        return _this;
    }
    AssemblyBase.prototype.getChildContext = function () { return this.computed.childContext; };
    AssemblyBase.prototype.componentWillMount = function () { return this.runLifeCycleCallbacks("componentWillMountCallback"); };
    AssemblyBase.prototype.componentDidMount = function () { return this.runLifeCycleCallbacks("componentDidMountCallback"); };
    AssemblyBase.prototype.componentWillUnmount = function () {
        this.unmounted = true;
        return this.runLifeCycleCallbacks("componentWillUnmountCallback");
    };
    AssemblyBase.prototype.componentWillUpdate = function () { return this.runLifeCycleCallbacks("componentWillUpdateCallback"); };
    AssemblyBase.prototype.componentDidUpdate = function () { return this.runLifeCycleCallbacks("componentDidUpdateCallback"); };
    AssemblyBase.prototype.componentWillReceiveProps = function (nextProps, nextContext) {
        this.newestProps = nextProps;
        this.newestContext = nextContext;
        this.handleDataUpdate({
            props: nextProps,
            context: nextContext,
            component: this.target,
        });
    };
    AssemblyBase.prototype.shouldComponentUpdate = function (nextProps, nextState, nextContext) {
        if (this.state !== nextState && !this.hasWillReceivePropsCallback) {
            // State based props was not computed before, do it now.
            this.handleDataUpdate({
                props: nextProps,
                context: nextContext,
                component: this.target,
            });
        }
        var callbacks = this.computed.lifeCycleCallbacks.shouldComponentUpdateCallback;
        if (callbacks) {
            for (var i = 0; i < callbacks.length; i++) {
                if (!callbacks[i]()) {
                    return false;
                }
            }
        }
        return true;
    };
    AssemblyBase.prototype.render = function () {
        var _a = this.computed, Component = _a.component, props = _a.props;
        if (!Component) {
            return null;
        }
        if (Component === this.target && this.isReferentiallyTransparent ||
            isReferentiallyTransparentFunctionComponent_1.default(Component)) {
            return Component(props);
        }
        return React.createElement(Component, __assign({}, props));
    };
    AssemblyBase.prototype.runLifeCycleCallbacks = function (name) {
        var callbacks = this.computed.lifeCycleCallbacks[name];
        if (callbacks) {
            callbacks.forEach(function (cb) { return cb(); });
        }
    };
    AssemblyBase.prototype.applyStateDiff = function (stateDiff) {
        this.newestState = __assign({}, this.newestState, stateDiff);
    };
    AssemblyBase.prototype.setStateWithLifeCycle = function (stateDiff, callback, init, startAt) {
        if (init === void 0) { init = this.defaultInit; }
        if (startAt === void 0) { startAt = 0; }
        if (this.pendingDataUpdate) {
            // we are in the middle of a data update.
            if (!this.pendingDataUpdate.dirty || startAt < this.pendingDataUpdate.startAt) {
                this.pendingDataUpdate.dirty = true;
                this.pendingDataUpdate.init = init;
                this.pendingDataUpdate.startAt = startAt;
            }
            if (callback) {
                this.pendingDataUpdate.callbacks.push(callback);
            }
            this.applyStateDiff(stateDiff);
        }
        else if (this.hasWillReceivePropsCallback) {
            // runs callbacks with the new state which will run the `componentWillReceiveProps` lifecycle
            this.handleDataUpdate(init, startAt, stateDiff, callback);
        }
        else {
            // state changes are batched and props will be recalculated in `shouldComponentUpdate`.
            this.applyStateDiff(stateDiff);
            this.setState(this.newestState, callback);
        }
    };
    Object.defineProperty(AssemblyBase.prototype, "defaultInit", {
        get: function () {
            return {
                props: this.newestProps,
                context: this.newestContext,
                component: this.target,
            };
        },
        enumerable: true,
        configurable: true
    });
    AssemblyBase.prototype.handleDataUpdate = function (init, startAt, stateDiff, callback) {
        if (init === void 0) { init = this.defaultInit; }
        if (startAt === void 0) { startAt = 0; }
        if (stateDiff === void 0) { stateDiff = {}; }
        if (callback === void 0) { callback = null; }
        var oldState = this.newestState;
        if (stateDiff) {
            this.applyStateDiff(stateDiff);
        }
        this.pendingDataUpdate = { callbacks: callback ? [callback] : [] };
        this.computed = this.runInstanceCallbacks(init, startAt);
        var callbacks = this.pendingDataUpdate.callbacks;
        this.pendingDataUpdate = null;
        if (this.newestState !== oldState) {
            // Component could be unmounted because something during the lifecycle call can
            // cause a parent component to unmount this before it completed its data update.
            if (!this.unmounted) {
                this.setState(this.newestState, function () { return callbacks.forEach(function (cb) { return cb(); }); });
            }
        }
    };
    AssemblyBase.prototype.runInstanceCallbacks = function (init, startAt) {
        var _this = this;
        if (startAt === void 0) { startAt = 0; }
        var interim = __assign({}, init);
        if (!interim.lifeCycleCallbacks) {
            interim.lifeCycleCallbacks = {};
        }
        var _loop_1 = function (idx) {
            var entry = this_1.callbackList[idx];
            switch (entry.kind) {
                case "propsCallback":
                    interim.props = entry.callback(interim.props, this_1.newestState, interim.context);
                    break;
                case "stateCallback":
                    {
                        var sc_1 = entry;
                        if (this_1.hasWillReceivePropsCallback) {
                            sc_1.init = __assign({}, interim);
                            sc_1.startAt = idx;
                        }
                        if (!sc_1.called) {
                            sc_1.called = true;
                            var initState = function (name, value) {
                                var unique = getUniqueKey_1.default(name, _this.newestState);
                                _this.applyStateDiff((_a = {}, _a[unique] = value, _a));
                                var updater = function (val, callback) {
                                    _this.setStateWithLifeCycle((_a = {}, _a[unique] = val, _a), callback, sc_1.init, sc_1.startAt);
                                    var _a;
                                };
                                return { name: unique, updater: updater };
                                var _a;
                            };
                            entry.callback(initState, interim.props, this_1.newestState, interim.context);
                        }
                    }
                    break;
                case "childContextCallback":
                    interim.childContext = entry.callback(interim.childContext, interim.props, this_1.newestState, interim.context);
                    break;
                case "skipCallback":
                    idx += entry.callback(interim.props, this_1.newestState, interim.context);
                    break;
                case "renderCallback":
                    interim.component = entry.callback(interim.component, interim.props, this_1.newestState, interim.context);
                    break;
                case "lazyLoadCallback":
                    var list = entry.callback(interim.props, this_1.newestState, interim.context);
                    if (list && list.length > 0) {
                        this_1.callbackList = this_1.callbackList.slice(0, idx + 1).concat(list, this_1.callbackList.slice(idx + 1));
                        if (!this_1.hasWillReceivePropsCallback) {
                            this_1.hasWillReceivePropsCallback = list.some(hasWillReceivePropsCallback);
                        }
                    }
                    break;
                case "componentWillReceivePropsCallback":
                    {
                        var cc = entry;
                        var callback = entry.callback(interim.props, this_1.newestState, interim.context);
                        if (cc.called && this_1.pendingDataUpdate) {
                            // Props changed so we need to run this lifecycle.
                            callback();
                            if (this_1.pendingDataUpdate.dirty) {
                                // State changed during lifecycle, so we need to recalculated from an earlier position.
                                this_1.pendingDataUpdate.dirty = false;
                                return { value: this_1.runInstanceCallbacks(this_1.pendingDataUpdate.init, this_1.pendingDataUpdate.startAt) };
                            }
                        }
                        else {
                            cc.called = true;
                        }
                    }
                    break;
                case "componentWillMountCallback":
                case "componentDidMountCallback":
                case "componentWillUnmountCallback":
                case "shouldComponentUpdateCallback":
                case "componentWillUpdateCallback":
                case "componentDidUpdateCallback":
                    {
                        var hasCallbacks = interim.lifeCycleCallbacks[entry.kind] !== undefined;
                        var callback = entry.callback(interim.props, this_1.newestState, interim.context);
                        interim.lifeCycleCallbacks = __assign({}, interim.lifeCycleCallbacks, (_a = {}, _a[entry.kind] = hasCallbacks
                            ? interim.lifeCycleCallbacks[entry.kind].concat([callback]) : [callback], _a));
                    }
                    break;
                default:
                    throw new Error("Unknown callback entry '" + entry.kind + "'");
            }
            out_idx_1 = idx;
            var _a;
        };
        var this_1 = this, out_idx_1;
        for (var idx = startAt; idx < this.callbackList.length; idx++) {
            var state_1 = _loop_1(idx);
            idx = out_idx_1;
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return interim;
    };
    return AssemblyBase;
}(react_1.Component));
function assemble() {
    var callbacks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        callbacks[_i] = arguments[_i];
    }
    var blueprint = blueprint_1.createBlueprint.apply(void 0, callbacks);
    return function (target) {
        var isReferentiallyTransparent = isReferentiallyTransparentFunctionComponent_1.default(target);
        var targetName = getDisplayName_1.default(target);
        var assembled = (_a = (function (_super) {
                __extends(class_1, _super);
                function class_1(props, context) {
                    return _super.call(this, blueprint, target, isReferentiallyTransparent, props, context) || this;
                }
                return class_1;
            }(AssemblyBase)),
            _a.displayName = isReferentiallyTransparent
                ? targetName
                : "Assembled(" + targetName + ")",
            _a);
        blueprint.staticCallbacks.forEach(function (cb) { return cb(assembled, target); });
        return assembled;
        var _a;
    };
}
exports.assemble = assemble;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = assemble;

//# sourceMappingURL=assemble.js.map
