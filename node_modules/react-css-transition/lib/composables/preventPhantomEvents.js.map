{"version":3,"sources":["composables/preventPhantomEvents.tsx"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,kBAAkB,EAAE,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,YAAY,CAAC;AAY/F,MAAM,CAAC,IAAM,oBAAoB,GAAG,OAAO,CACzC,YAAY,CACV;IACE,IAAI,eAAoB,CAAC;IACzB,IAAI,0BAA+B,CAAC;IACpC,IAAI,mBAAmB,GAAG,KAAK,CAAC;IAChC,MAAM,CAAC;QACL,iBAAiB,EAAE,cAAM,OAAA;YACvB,mBAAmB,GAAG,IAAI,CAAC;QAC7B,CAAC,EAFwB,CAExB;QACD,uBAAuB,EAAE,cAAM,OAAA;YAC7B,EAAE,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;gBACxB,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBAC7B,EAAE,CAAC,CAAC,OAAO,WAAW,KAAK,WAAW;oBACpC,OAAO,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,CAAC;oBACzC,0BAA0B,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;gBACjD,CAAC;gBACD,mBAAmB,GAAG,KAAK,CAAC;YAC9B,CAAC;QACH,CAAC,EAT8B,CAS9B;QACD,eAAe,EAAE,UAAC,EAAiB;gBAAhB,oCAAe;YAAM,OAAA,UAAC,CAAuB;gBAC9D,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;oBAAC,MAAM,CAAC;gBAAC,CAAC;gBAEjC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;oBACjC,eAAe,CAAC,CAAC,CAAC,CAAC;oBACnB,MAAM,CAAC;gBACT,CAAC;gBAED,wEAAwE;gBACxE,wDAAwD;gBACxD,IAAI,WAAW,GAAG,eAAe,CAAC;gBAClC,EAAE,CAAC,CAAE,CAAC,CAAC,SAAiB,GAAG,aAAa,IAAI,0BAA0B,CAAC,CAAC,CAAC;oBACvE,WAAW,GAAG,0BAA0B,CAAC;gBAC3C,CAAC;gBACD,EAAE,CAAC,CAAE,CAAC,CAAC,SAAiB,GAAG,WAAW,IAAI,EAAE,CAAC,CAAC,CAAC;oBAC7C,MAAM,CAAC;gBACT,CAAC;gBAED,eAAe,CAAC,CAAC,CAAC,CAAC;YACrB,CAAC;QAnBuC,CAmBvC;KACF,CAAC;AACJ,CAAC,CAAC,EACJ,kBAAkB,CAChB,UAAC,EAAQ,EAAE,EAAuC;QAAhD,kBAAM;QAAI,sBAAkB,EAAE,wCAAiB;IAC/C,EAAE,CAAC,CAAC,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC;QAC1B,iBAAiB,EAAE,CAAC;IACtB,CAAC;AACH,CAAC,CAAC,EACJ,WAAW,CACT,UAAC,EAAyB;QAAxB,oDAAuB;IAAM,OAAA,uBAAuB,EAAE;AAAzB,CAAyB,CACzD,EACD,SAAS,CACP,iBAAiB,CAClB,CACF,CAAC","file":"preventPhantomEvents.js","sourcesContent":["import { EventHandler, TransitionEvent } from \"react\";\nimport { withHandlers, onWillReceiveProps, onDidUpdate, isolate, integrate } from \"reassemble\";\n\nimport { CSSTransitionProps } from \"../csstransition\";\n\ntype PropsOut = {\n  requestTimeUpdate?: () => void;\n  handleTimeUpdateRequest?: () => void;\n  onTransitionEnd?: EventHandler<TransitionEvent<any>>;\n};\n\ntype PropsUnion = CSSTransitionProps & PropsOut;\n\nexport const preventPhantomEvents = isolate(\n  withHandlers<PropsUnion, PropsOut>(\n    () => {\n      let lastTriggerTime: any;\n      let lastTriggerTimePerformance: any;\n      let timeUpdateRequested = false;\n      return {\n        requestTimeUpdate: () => () => {\n          timeUpdateRequested = true;\n        },\n        handleTimeUpdateRequest: () => () => {\n          if (timeUpdateRequested) {\n            lastTriggerTime = Date.now();\n            if (typeof performance !== \"undefined\" &&\n              typeof performance.now !== \"undefined\") {\n              lastTriggerTimePerformance = performance.now();\n            }\n            timeUpdateRequested = false;\n          }\n        },\n        onTransitionEnd: ({onTransitionEnd}) => (e: TransitionEvent<any>) => {\n          if (!onTransitionEnd) { return; }\n\n          if (e.target !== e.currentTarget) {\n            onTransitionEnd(e);\n            return;\n          }\n\n          // Skip transitionEnd that comes <= 10ms after (reversing) a transition.\n          // In most cases this came from the previous transition.\n          let compareWith = lastTriggerTime;\n          if ((e.timeStamp as any) < 1000000000000 && lastTriggerTimePerformance) {\n            compareWith = lastTriggerTimePerformance;\n          }\n          if ((e.timeStamp as any) - compareWith <= 10) {\n            return;\n          }\n\n          onTransitionEnd(e);\n        },\n      };\n    }),\n  onWillReceiveProps<PropsUnion>(\n    ({active}, {active: nextActive, requestTimeUpdate}) => {\n      if (active !== nextActive) {\n        requestTimeUpdate();\n      }\n    }),\n  onDidUpdate<PropsUnion>(\n    ({handleTimeUpdateRequest}) => handleTimeUpdateRequest(),\n  ),\n  integrate<keyof PropsUnion>(\n    \"onTransitionEnd\",\n  ),\n);\n"]}